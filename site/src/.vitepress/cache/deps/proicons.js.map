{
  "version": 3,
  "sources": ["../../../../../node_modules/proicons/dist/webpack:/proicons/webpack/universalModuleDefinition", "../../../../../node_modules/proicons/dist/webpack:/proicons/bin/rename.js", "../../../../../node_modules/proicons/dist/webpack:/proicons/webpack/bootstrap", "../../../../../node_modules/proicons/dist/webpack:/proicons/webpack/runtime/define property getters", "../../../../../node_modules/proicons/dist/webpack:/proicons/webpack/runtime/hasOwnProperty shorthand", "../../../../../node_modules/proicons/dist/webpack:/proicons/src/categories.ts", "../../../../../node_modules/proicons/dist/webpack:/proicons/src/interfaces.ts", "../../../../../node_modules/proicons/dist/webpack:/proicons/src/getIconInfo.ts", "../../../../../node_modules/proicons/dist/webpack:/proicons/src/proicons.ts", "../../../../../node_modules/proicons/dist/webpack:/proicons/src/replace.ts", "../../../../../node_modules/proicons/dist/webpack:/proicons/src/search.ts"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"proicons\"] = factory();\n\telse\n\t\troot[\"proicons\"] = factory();\n})(self, () => {\nreturn ", "function removeParenthesis(str) {\r\n    return str.replace(/[()]/g, '')\r\n}\r\nfunction camelCase(str) {\r\n    return removeParenthesis(str).split(' ').map((word, i) => i == 0 ? word.toLowerCase() : word.charAt(0).toUpperCase() + word.slice(1)).join('')\r\n}\r\nfunction kebabCase(str) {\r\n    return removeParenthesis(str).replaceAll(' ', '-').toLowerCase()\r\n}\r\nmodule.exports = { camelCase, kebabCase };", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};", "__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))", "import icons from './configs/tags.json'\r\n\r\n/** List of all icon categories */\r\nconst categories = Object.values(icons).map((item) => item.category).filter((value, index, self) => self.indexOf(value) === index)\r\n\r\nexport default categories", "export interface ProIconReplaceConfig {\r\n    /** Determines the color of the icons. Defaults to `currentColor`. */\r\n    color: string,\r\n    /** Determines the default stroke width of the icon. Defaults to `1.5`. This only works on SVG elements with existing strokes; add `strokeFilledElements` for this property to affect such elements. */\r\n    strokeWidth: number,\r\n    /** Apply strokes to filled SVG elements, such as circles, by the provided amount with `1.5` (default stroke value) subtracted, if `strokeWidth` is set to a value above `1.5`. Defaults to `false`\r\n     * @example If `strokeWidth` is set to `2`, filled SVG elements will have an additional `0.5`px stroke\r\n     */\r\n    strokeFilledElements: boolean\r\n    /** Defaults to `round` */\r\n    strokeCaps: 'round' | 'square' | 'butt',\r\n    /** Defaults to `round` */\r\n    strokeJoin: 'round' | 'miter' | 'bevel',\r\n    /** Determines the corner radius of SVG elements. Does not apply to all rounded elements. */\r\n    cornerRadius: number,\r\n    /** The attribute name that is checked for when converting elements to icons. Defaults to `proicon`. */\r\n    attributeName: string,\r\n    /** Determines whether to overwrite elements when converting to icons. Setting this to `auto` will overwrite only if the element does not have any children. Defaults to `auto`. */\r\n    overwrite: boolean | 'auto',\r\n    /** Determines whether to apply existing HTMl attributes such as styles to the converted SVGs. Defaults to `true` */\r\n    useAttributes: false\r\n}\r\n\r\nexport class ProIconInfo {\r\n    name: string;\r\n    kebabCase: string;\r\n    camelCase: string;\r\n    element: SVGElement;\r\n    category: string;\r\n    tags: string[];\r\n    /**\r\n     * \r\n     * @param name The name of the icon in Friendly Form\r\n     * @param kebabCase The name of the icon in kebab-case\r\n     * @param camelCase The name of the icon in camelCase\r\n     * @param element The icon as an `SVGElement`. Use the `outerHTML` property on this to return the icon as a string.\r\n     * @param category The category of the icon.\r\n     * @param tags An array of the icon's tags.\r\n     */\r\n    constructor(\r\n        name: string,\r\n        kebabCase: string,\r\n        camelCase: string,\r\n        element: SVGElement,\r\n        tags: string[],\r\n        category: string\r\n    ) {\r\n        this.name = name;\r\n        this.kebabCase = kebabCase;\r\n        this.camelCase = camelCase;\r\n        this.element = element;\r\n        this.category = category;\r\n        this.tags = tags;\r\n    }\r\n}", "import icons from './configs/icons.json';\r\nimport tags from './configs/tags.json';\r\nimport { ProIconInfo } from './interfaces';\r\nconst rename = require('../bin/rename');\r\n\r\n/**\r\n * Returns information about an icon from the provided key.\r\n * Throws an error if the provided key does not match an icon name in Friendly Form, camelCase or kebab-case. Use the method `search` instead to return icons that contain a keyword inside its name or tags.\r\n * @param key The icon name in Friendly Form, camelCase or kebab-case. Throws an error if the provided key is invalid. Case-insensitive\r\n * @example The following keys are valid:\r\n * getIconInfo('Add Square')\r\n * getIconInfo('addSquare')\r\n * getIconInfo('add-square')\r\n */\r\nfunction getIconInfo(key: string): ProIconInfo {\r\n    let prop: string;\r\n\r\n    const isFriendly = (t: string) => t.toLowerCase() == key.toLowerCase();\r\n    const isKebab = (t: string) => rename.kebabCase(t.toLowerCase()) == rename.kebabCase(key.toLowerCase());\r\n    const isCamel = isFriendly\r\n\r\n    if (Object.keys(tags).some(isFriendly)) {\r\n        prop = rename.camelCase(Object.keys(tags).find(isFriendly));\r\n\r\n    } else if (Object.keys(tags).some(isKebab)) {\r\n        prop = rename.camelCase(Object.keys(tags).find(isKebab));\r\n\r\n    } else if (Object.keys(icons).some(isCamel)) {\r\n        // @ts-ignore\r\n        prop = Object.keys(icons).find(isCamel);\r\n\r\n    } else {\r\n        throw new Error(`Invalid icon key '${key}': Icon not found`);\r\n    }\r\n\r\n    const friendlyName = Object.keys(tags).find((t) => {\r\n        return rename.camelCase(t) == prop;\r\n    });\r\n\r\n    const domParser = new DOMParser();\r\n    const parsed = domParser.parseFromString(icons[prop], 'image/svg+xml');\r\n\r\n    const tagItem = tags[friendlyName]\r\n    const info = new ProIconInfo(\r\n        friendlyName, //friendly\r\n        rename.kebabCase(friendlyName), //kebab\r\n        prop, //camel\r\n        parsed.querySelector('svg'), //svg\r\n        tagItem.description?.split(',').map(m => m.trim()), //desc\r\n        tagItem.category, //tags\r\n    );\r\n    return info;\r\n}\r\n\r\nexport default getIconInfo", "import icons from './configs/icons.json';\r\nimport categories from './categories'\r\nimport replace from './replace'\r\nimport getIconInfo from './getIconInfo'\r\nimport search from './search'\r\n\r\nexport default { icons, replace, getIconInfo, categories, search };", "// @ts-nocheck\r\nimport getIconInfo from './getIconInfo'\r\nimport { ProIconReplaceConfig, ProIconInfo } from './interfaces';\r\n\r\n/**\r\n * Converts all elements with the `proicon` attribute (which can be customised in the config) on the page to an icon corresponding to the attribute value.\r\n * @param rootElm The element to search inside for children with the `proicon` attribute. Defaults to `document.body`.\r\n * @param config An optional configuration to customise the behaviour of the replace method\r\n */\r\nfunction replace(rootElm?: Element, config?: ProIconReplaceConfig): void {\r\n    if (!rootElm) rootElm = document.body;\r\n    const useAttrs = config?.useAttributes ?? true\r\n\r\n    const attr = config?.attributeName ?? 'proicon';\r\n    rootElm.querySelectorAll(`[${attr}]`).forEach((element) => {\r\n        let toReplace;\r\n        switch (config?.overwrite) {\r\n            case true: toReplace = true; break;\r\n            case false: toReplace = false; break;\r\n            case 'auto': toReplace = !element.hasChildNodes(); break;\r\n            default: toReplace = !element.hasChildNodes(); break;\r\n        }\r\n\r\n        let iconName = element.getAttribute(attr).trim()\r\n        let icon: SVGElement = getIconInfo(iconName).element\r\n\r\n        const attributeList = {\r\n            // HtmlAttribute, configKey, svgAttr\r\n            \"color\": [\"color\", [\"stroke\", 'fill']],\r\n            \"stroke-width\": [\"strokeWidth\", [\"stroke-width\"]],\r\n            \"join\": [\"strokeCaps\", [\"stroke-linejoin\"]],\r\n            \"caps\": [\"strokeJoin\", [\"stroke-linecap\"]],\r\n            \"corner-radius\": [\"cornerRadius\", [\"rx\"]],\r\n            \"outline\": [\"strokeFilledElements\", undefined]\r\n        }\r\n        if (config) {\r\n            Object.values(attributeList)\r\n                .map((v) => v[0])\r\n                .forEach((c, i) => {\r\n                    const htmlAttr = Object.keys(attributeList)[i];\r\n                    let valueToUse\r\n\r\n                    if (useAttrs && element.hasAttribute(htmlAttr)) {\r\n                        valueToUse = element.getAttribute(htmlAttr)\r\n                    } else if (config[c]) {\r\n                        valueToUse = config[c]\r\n                    }\r\n\r\n                    if (valueToUse) {\r\n                        element.setAttribute(htmlAttr, valueToUse);\r\n                    }\r\n                });\r\n        }\r\n        for (const attr of element.attributes) {\r\n            const name = attr.name.toLowerCase()\r\n            const value = attr.value\r\n\r\n            if (Object.hasOwn(attributeList, name)) {\r\n                if (name != 'outline') {\r\n                    if (value) {\r\n                        const n = attributeList[name][1]\r\n                        n.forEach(x => {\r\n                            icon.querySelectorAll(`[${x}]`).forEach(b => {\r\n                                b.setAttribute(x, value)\r\n                            })\r\n                        })\r\n                    }\r\n                } else {\r\n                    // Behaviour for outlining\r\n                    const defaultStrokeWidth = 1.5\r\n                    const unstrokedElms = Array.from(icon.querySelectorAll('*')).filter(f => !f.hasAttribute('stroke'))\r\n\r\n                    unstrokedElms.forEach(elm => {\r\n                        const reducedStroke = +element.getAttribute('stroke-width') - defaultStrokeWidth\r\n                        if (reducedStroke > 0) {\r\n                            elm.setAttribute('stroke', element.getAttribute('color') ?? 'currentColor')\r\n                            elm.setAttribute('stroke-width', reducedStroke)\r\n                            elm.setAttribute('stroke-linejoin', element.getAttribute('strokeJoin') ?? 'round')\r\n                            elm.setAttribute('stroke-linecap', element.getAttribute('strokeCaps') ?? 'round')\r\n                        }\r\n                    })\r\n                }\r\n            } else {\r\n                icon.setAttribute(name, value)\r\n            }\r\n        }\r\n\r\n\r\n        icon.classList.add('proicon')\r\n        icon.setAttribute('data-proicon-id', getIconInfo(iconName).kebabCase)\r\n\r\n        toReplace == true ? element.replaceWith(icon)\r\n            : element.insertBefore(icon, element.childNodes[0])\r\n    });\r\n}\r\n\r\nexport default replace\r\n", "import getIconInfo from \"./getIconInfo\"\r\nimport tags from './configs/tags.json'\r\nimport icons from './configs/icons.json'\r\nimport { ProIconInfo } from \"./interfaces\"\r\n\r\n/** Searches for icons with names or tags that contain `key` and returns them as `ProIconInfo`. */\r\nfunction search(key: string): ProIconInfo[] {\r\n    const iconsAsInfo = Object.keys(icons).map((icon) => {\r\n        // Don't index the element\r\n        const j = getIconInfo(icon)\r\n        delete j.element\r\n        return j\r\n    })\r\n    const filtered = iconsAsInfo.filter((icon) => JSON.stringify(icon).includes(key))\r\n\r\n    return filtered\r\n}\r\n\r\nexport default search"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "define", "amd", "self", "r", "removeParenthesis", "str", "replace", "camelCase", "split", "map", "word", "i", "toLowerCase", "charAt", "toUpperCase", "slice", "join", "kebabCase", "replaceAll", "__webpack_module_cache__", "__webpack_require__", "moduleId", "cachedModule", "__webpack_modules__", "d", "definition", "key", "o", "Object", "defineProperty", "enumerable", "get", "obj", "prop", "prototype", "hasOwnProperty", "call", "values", "item", "category", "filter", "value", "index", "indexOf", "ProIconInfo", "name", "element", "tags", "this", "rename", "isFriendly", "t", "isKebab", "isCamel", "keys", "some", "find", "Error", "friendlyName", "parsed", "DOMParser", "parseFromString", "tagItem", "querySelector", "description", "m", "trim", "icons", "rootElm", "config", "document", "body", "useAttrs", "useAttributes", "attr", "attributeName", "querySelectorAll", "forEach", "toReplace", "overwrite", "hasChildNodes", "iconName", "getAttribute", "icon", "attributeList", "undefined", "v", "c", "htmlAttr", "valueToUse", "hasAttribute", "setAttribute", "attributes", "hasOwn", "x", "b", "defaultStrokeWidth", "Array", "from", "f", "elm", "reducedStroke", "classList", "add", "replaceWith", "insertBefore", "childNodes", "getIconInfo", "categories", "search", "j", "JSON", "stringify", "includes"]
}
